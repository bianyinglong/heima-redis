package com.hmdp.utils;import cn.hutool.core.util.BooleanUtil;import cn.hutool.core.util.StrUtil;import cn.hutool.json.JSONObject;import cn.hutool.json.JSONUtil;import lombok.extern.slf4j.Slf4j;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.stereotype.Component;import java.time.LocalDateTime;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.TimeUnit;import java.util.function.Function;import static com.hmdp.utils.RedisConstants.CACHE_NULL_TTL;@Slf4j@Componentpublic class CacheClient {    private final StringRedisTemplate stringRedisTemplate;    private static final ExecutorService CACHE_REBUILD_EXECUTOR = Executors.newFixedThreadPool(10);    public CacheClient(StringRedisTemplate stringRedisTemplate) {        this.stringRedisTemplate = stringRedisTemplate;    }    public void set(String key, Object value, Long time, TimeUnit unit) {        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time, unit);    }    public void setWithLogicExpire(String key, Object value, Long time, TimeUnit unit) {        RedisData redisData = new RedisData();        redisData.setData(value);        redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(time)));        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));    }    /**     * 设置空值，解决缓存穿透问题     *     * @return: R     */    public <R, ID> R queryWithPassThrough(String keyPrefix, ID id, Class<R> type,                                          Function<ID, R> dbCallback, Long time, TimeUnit unit) {        String key = keyPrefix + id;        // 1.从redis缓存中查询        String json = stringRedisTemplate.opsForValue().get(key);        if (StrUtil.isNotBlank(json)) {            return JSONUtil.toBean(json, type);        }        // 说明json是一个空字符串        if (json != null) return null;        R result = dbCallback.apply(id);        if (result == null) {            // 数据库中没有查询到，返回错误，并写入空值到redis            stringRedisTemplate.opsForValue().set(key, "", CACHE_NULL_TTL, TimeUnit.MINUTES);            return null;        }        // 数据库中存在，写入redis        this.set(key, result, time, unit);        return result;    }    /**     * 互斥锁，解决缓存击穿问题     *     * @return: R     */    public <R, ID> R queryWithMutex(String keyPrefix, String lockKeyPre, ID id, Class<R> type,                                    Function<ID, R> dbCallback, Long time, TimeUnit unit) {        String key = keyPrefix + id;        String json = stringRedisTemplate.opsForValue().get(key);        if (StrUtil.isNotBlank(json)) {            return JSONUtil.toBean(json, type);        }        if (json != null) return null;        String lockKey = lockKeyPre + id;        R result = null;        try {            boolean isLock = tryLock(lockKey);            if (!isLock) {                // 获取不到锁，说明其他线程正在使用，休眠并重试                Thread.sleep(50);                return queryWithMutex(keyPrefix, lockKeyPre, id, type, dbCallback, time, unit);            }            // 查询数据库            result = dbCallback.apply(id);            // 模拟重建时的延迟            // Thread.sleep(200);            if (result == null) {                // 数据库中没有查询到，返回错误，并写入空值到redis                stringRedisTemplate.opsForValue().set(key, "", CACHE_NULL_TTL, TimeUnit.MINUTES);                return null;            }            // 数据库中存在，写入redis            this.set(key, result, time, unit);        } catch (InterruptedException e) {            throw new RuntimeException(e);        } finally {            // 释放锁            unlock(lockKey);        }        return result;    }    // 逻辑过期时间，解决缓存击穿问题    public <R, ID> R queryWithLogicExpire(String keyPrefix, String lockKeyPre, ID id, Class<R> type,                                          Function<ID, R> dbCallback, Long time, TimeUnit unit) {        String key = keyPrefix + id;        String json = stringRedisTemplate.opsForValue().get(key);        if (StrUtil.isBlank(json)) return null;        RedisData redisData = JSONUtil.toBean(json, RedisData.class);        R result = JSONUtil.toBean((JSONObject) redisData.getData(), type);        LocalDateTime expireTime = redisData.getExpireTime();        // 未过期，直接返回店铺信息        if (expireTime.isAfter(LocalDateTime.now())) return result;        // 已经过期，获取锁，开启线程        String lockKey = lockKeyPre + id;        if (tryLock(lockKey)) {            CACHE_REBUILD_EXECUTOR.submit(() -> {                try {                    R res = dbCallback.apply(id);                    this.setWithLogicExpire(key, res, time, unit);                } catch (Exception e) {                    throw new RuntimeException(e);                } finally {                    unlock(lockKey);                }            });        }        // 返回redis中逻辑过期的数据        return result;    }    // 尝试获取锁    private boolean tryLock(String key) {        Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key, "1", 10, TimeUnit.SECONDS);        return BooleanUtil.isTrue(flag);    }    // 释放锁    private void unlock(String key) {        stringRedisTemplate.delete(key);    }}